/********************************************************************
* 给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的
* 字母，并删除它们。
* 在 S 上反复执行重复项删除操作，直到无法继续删除。
* 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。
* 示例：
* 输入："abbaca"
* 输出："ca"
* 解释：
* 例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，
* 这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，
* 其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
*********************************************************************/
/**********************************************************************
 * 遇到的11个问题
 * 0.内存，开始的时候借助辅助空间，内存超出限制
 * 1.时间，开始的时候使用size()函数次数过多
 * 2.erase(a,n)函数，a是起始位置，n是删除从位置a开始的个数
 *********************************************************************/
class Solution {
public:
    string removeDuplicates(string S) {
        /****************************
         * 测试用例简直就是丧心病狂啊
         ***************************/
        // 考虑字符串S为空
        if(S.size()<2)
        {
            return S;
        }
        int len_low = 0;
        int len_high = 1;
        int len_s =  S.size(); // 记录S的长度
        while(len_high<len_s)
        {
            // 如果不等直接插入到result字符串末尾
            if(S[len_low]!=S[len_high])
            {
                len_low++;
                len_high++;
                continue;
            }
            while(len_s>1 && S[len_low]==S[len_high])
            {
                if(len_low) // 如果len_low指针为零，则指针不变
                {
                    S.erase(len_low,2);
                    len_low--;
                    len_high--;
                }
                else{
                    S.erase(len_low,2);
                }
                len_s = S.size();
            }
        }
        return S;
    }
};